diff --git gymnasium/envs/mujoco/mujoco_env.py gymnasium/envs/mujoco/mujoco_env.py
index 44dc8cee..cc69264c 100644
--- gymnasium/envs/mujoco/mujoco_env.py
+++ gymnasium/envs/mujoco/mujoco_env.py
@@ -2,7 +2,6 @@ from os import path
 from typing import Any, Dict, Optional, Tuple, Union

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium import error, logger, spaces
@@ -102,7 +101,7 @@ class BaseMujocoEnv(gym.Env[np.float64, np.float32]):
     # methods to override:
     # ----------------------------

-    def reset_model(self) -> NDArray[np.float64]:
+    def reset_model(self) -> np.ndarray:
         """
         Reset the robot degrees of freedom (qpos and qvel).
         Implement this in each subclass.
@@ -127,7 +126,7 @@ class BaseMujocoEnv(gym.Env[np.float64, np.float32]):
         """
         raise NotImplementedError

-    def render(self) -> Union[NDArray[np.float64], None]:
+    def render(self) -> Union[np.ndarray, None]:
         """
         Render a frame from the MuJoCo simulation as specified by the render_mode.
         """
@@ -180,11 +179,11 @@ class BaseMujocoEnv(gym.Env[np.float64, np.float32]):
         """Close all processes like rendering contexts"""
         raise NotImplementedError

-    def get_body_com(self, body_name) -> NDArray[np.float64]:
+    def get_body_com(self, body_name) -> np.ndarray:
         """Return the cartesian position of a body frame"""
         raise NotImplementedError

-    def state_vector(self) -> NDArray[np.float64]:
+    def state_vector(self) -> np.ndarray:
         """Return the position and velocity joint states of the model"""
         return np.concatenate([self.data.qpos.flat, self.data.qvel.flat])

diff --git gymnasium/spaces/box.py gymnasium/spaces/box.py
index 3b75ab4f..557a53e0 100644
--- gymnasium/spaces/box.py
+++ gymnasium/spaces/box.py
@@ -4,13 +4,12 @@ from __future__ import annotations
 from typing import Any, Iterable, Mapping, Sequence, SupportsFloat

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium.spaces.space import Space


-def _short_repr(arr: NDArray[Any]) -> str:
+def _short_repr(arr: np.ndarray) -> str:
     """Create a shortened string representation of a numpy array.

     If arr is a multiple of the all-ones vector, return a string representation of the multiplier.
@@ -32,7 +31,7 @@ def is_float_integer(var: Any) -> bool:
     return np.issubdtype(type(var), np.integer) or np.issubdtype(type(var), np.floating)


-class Box(Space[NDArray[Any]]):
+class Box(Space[np.ndarray]):
     r"""A (possibly unbounded) box in :math:`\mathbb{R}^n`.

     Specifically, a Box represents the Cartesian product of n closed intervals.
@@ -54,8 +53,8 @@ class Box(Space[NDArray[Any]]):

     def __init__(
         self,
-        low: SupportsFloat | NDArray[Any],
-        high: SupportsFloat | NDArray[Any],
+        low: SupportsFloat | np.ndarray,
+        high: SupportsFloat | np.ndarray,
         shape: Sequence[int] | None = None,
         dtype: type[np.floating[Any]] | type[np.integer[Any]] = np.float32,
         seed: int | np.random.Generator | None = None,
@@ -104,10 +103,10 @@ class Box(Space[NDArray[Any]]):

         # Capture the boundedness information before replacing np.inf with get_inf
         _low = np.full(shape, low, dtype=float) if is_float_integer(low) else low
-        self.bounded_below: NDArray[np.bool_] = -np.inf < _low
+        self.bounded_below: np.ndarray = -np.inf < _low

         _high = np.full(shape, high, dtype=float) if is_float_integer(high) else high
-        self.bounded_above: NDArray[np.bool_] = np.inf > _high
+        self.bounded_above: np.ndarray = np.inf > _high

         low = _broadcast(low, self.dtype, shape)
         high = _broadcast(high, self.dtype, shape)
@@ -181,7 +180,7 @@ class Box(Space[NDArray[Any]]):
                 f"manner is not in {{'below', 'above', 'both'}}, actual value: {manner}"
             )

-    def sample(self, mask: None = None) -> NDArray[Any]:
+    def sample(self, mask: None = None) -> np.ndarray:
         r"""Generates a single random sample inside the Box.

         In creating a sample of the box, each coordinate is sampled (independently) from a distribution
@@ -250,11 +249,11 @@ class Box(Space[NDArray[Any]]):
             and np.all(x <= self.high)
         )

-    def to_jsonable(self, sample_n: Sequence[NDArray[Any]]) -> list[list]:
+    def to_jsonable(self, sample_n: Sequence[np.ndarray]) -> list[list]:
         """Convert a batch of samples from this space to a JSONable data type."""
         return [sample.tolist() for sample in sample_n]

-    def from_jsonable(self, sample_n: Sequence[float | int]) -> list[NDArray[Any]]:
+    def from_jsonable(self, sample_n: Sequence[float | int]) -> list[np.ndarray]:
         """Convert a JSONable data type to a batch of samples from this space."""
         return [np.asarray(sample, dtype=self.dtype) for sample in sample_n]

@@ -300,10 +299,10 @@ def get_precision(dtype: np.dtype) -> SupportsFloat:


 def _broadcast(
-    value: SupportsFloat | NDArray[Any],
+    value: SupportsFloat | np.ndarray,
     dtype: np.dtype,
     shape: tuple[int, ...],
-) -> NDArray[Any]:
+) -> np.ndarray:
     """Handle infinite bounds and broadcast at the same time if needed.

     This is needed primarily because:
diff --git gymnasium/spaces/graph.py gymnasium/spaces/graph.py
index d2be47e8..f6fc481f 100644
--- gymnasium/spaces/graph.py
+++ gymnasium/spaces/graph.py
@@ -4,7 +4,6 @@ from __future__ import annotations
 from typing import Any, NamedTuple, Sequence

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium.spaces.box import Box
@@ -21,9 +20,9 @@ class GraphInstance(NamedTuple):
     * edge_links (Optional[np.ndarray]): an (m x 2) sized array of ints representing the indices of the two nodes that each edge connects.
     """

-    nodes: NDArray[Any]
-    edges: NDArray[Any] | None
-    edge_links: NDArray[Any] | None
+    nodes: np.ndarray
+    edges: np.ndarray | None
+    edge_links: np.ndarray | None


 class Graph(Space[GraphInstance]):
@@ -115,8 +114,8 @@ class Graph(Space[GraphInstance]):
         mask: None
         | (
             tuple[
-                NDArray[Any] | tuple[Any, ...] | None,
-                NDArray[Any] | tuple[Any, ...] | None,
+                np.ndarray | tuple[Any, ...] | None,
+                np.ndarray | tuple[Any, ...] | None,
             ]
         ) = None,
         num_nodes: int = 10,
diff --git gymnasium/spaces/multi_binary.py gymnasium/spaces/multi_binary.py
index 63500332..af599e35 100644
--- gymnasium/spaces/multi_binary.py
+++ gymnasium/spaces/multi_binary.py
@@ -4,12 +4,11 @@ from __future__ import annotations
 from typing import Any, Sequence

 import numpy as np
-from numpy.typing import NDArray

 from gymnasium.spaces.space import MaskNDArray, Space


-class MultiBinary(Space[NDArray[np.int8]]):
+class MultiBinary(Space[np.ndarray]):
     """An n-shape binary space.

     Elements of this space are binary arrays of a shape that is fixed during construction.
@@ -28,7 +27,7 @@ class MultiBinary(Space[NDArray[np.int8]]):

     def __init__(
         self,
-        n: NDArray[np.integer[Any]] | Sequence[int] | int,
+        n: np.ndarray | Sequence[int] | int,
         seed: int | np.random.Generator | None = None,
     ):
         """Constructor of :class:`MultiBinary` space.
@@ -58,7 +57,7 @@ class MultiBinary(Space[NDArray[np.int8]]):
         """Checks whether this space can be flattened to a :class:`spaces.Box`."""
         return True

-    def sample(self, mask: MaskNDArray | None = None) -> NDArray[np.int8]:
+    def sample(self, mask: MaskNDArray | None = None) -> np.ndarray:
         """Generates a single random sample from this space.

         A sample is drawn by independent, fair coin tosses (one toss per binary variable of the space).
@@ -104,11 +103,11 @@ class MultiBinary(Space[NDArray[np.int8]]):
             and np.all(np.logical_or(x == 0, x == 1))
         )

-    def to_jsonable(self, sample_n: Sequence[NDArray[np.int8]]) -> list[Sequence[int]]:
+    def to_jsonable(self, sample_n: Sequence[np.ndarray]) -> list[Sequence[int]]:
         """Convert a batch of samples from this space to a JSONable data type."""
         return np.array(sample_n).tolist()

-    def from_jsonable(self, sample_n: list[Sequence[int]]) -> list[NDArray[np.int8]]:
+    def from_jsonable(self, sample_n: list[Sequence[int]]) -> list[np.ndarray]:
         """Convert a JSONable data type to a batch of samples from this space."""
         return [np.asarray(sample, self.dtype) for sample in sample_n]

diff --git gymnasium/spaces/multi_discrete.py gymnasium/spaces/multi_discrete.py
index fcde1059..658721c0 100644
--- gymnasium/spaces/multi_discrete.py
+++ gymnasium/spaces/multi_discrete.py
@@ -4,14 +4,13 @@ from __future__ import annotations
 from typing import Any, Iterable, Mapping, Sequence

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium.spaces.discrete import Discrete
 from gymnasium.spaces.space import MaskNDArray, Space


-class MultiDiscrete(Space[NDArray[np.integer]]):
+class MultiDiscrete(Space[np.ndarray]):
     """This represents the cartesian product of arbitrary :class:`Discrete` spaces.

     It is useful to represent game controllers or keyboards where each key can be represented as a discrete action space.
@@ -41,10 +40,10 @@ class MultiDiscrete(Space[NDArray[np.integer]]):

     def __init__(
         self,
-        nvec: NDArray[np.integer[Any]] | list[int],
+        nvec: np.ndarray | list[int],
         dtype: str | type[np.integer[Any]] = np.int64,
         seed: int | np.random.Generator | None = None,
-        start: NDArray[np.integer[Any]] | list[int] | None = None,
+        start: np.ndarray | list[int] | None = None,
     ):
         """Constructor of :class:`MultiDiscrete` space.

@@ -83,7 +82,7 @@ class MultiDiscrete(Space[NDArray[np.integer]]):

     def sample(
         self, mask: tuple[MaskNDArray, ...] | None = None
-    ) -> NDArray[np.integer[Any]]:
+    ) -> np.ndarray:
         """Generates a single random sample this space.

         Args:
@@ -163,14 +162,14 @@ class MultiDiscrete(Space[NDArray[np.integer]]):
         )

     def to_jsonable(
-        self, sample_n: Sequence[NDArray[np.integer[Any]]]
+        self, sample_n: Sequence[np.ndarray]
     ) -> list[Sequence[int]]:
         """Convert a batch of samples from this space to a JSONable data type."""
         return [sample.tolist() for sample in sample_n]

     def from_jsonable(
         self, sample_n: list[Sequence[int]]
-    ) -> list[NDArray[np.integer[Any]]]:
+    ) -> list[np.ndarray]:
         """Convert a JSONable data type to a batch of samples from this space."""
         return [np.array(sample) for sample in sample_n]

diff --git gymnasium/spaces/sequence.py gymnasium/spaces/sequence.py
index 1311316f..2f5cd9dd 100644
--- gymnasium/spaces/sequence.py
+++ gymnasium/spaces/sequence.py
@@ -5,7 +5,6 @@ import typing
 from typing import Any, Union

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium.spaces.space import Space
@@ -69,7 +68,7 @@ class Sequence(Space[Union[typing.Tuple[Any, ...], Any]]):
         mask: None
         | (
             tuple[
-                None | np.integer | NDArray[np.integer],
+                None | np.integer | np.ndarray,
                 Any,
             ]
         ) = None,
diff --git gymnasium/spaces/space.py gymnasium/spaces/space.py
index 089611df..de372c4c 100644
--- gymnasium/spaces/space.py
+++ gymnasium/spaces/space.py
@@ -4,7 +4,6 @@ from __future__ import annotations
 from typing import Any, Generic, Iterable, Mapping, Sequence, TypeVar

 import numpy as np
-import numpy.typing as npt

 from gymnasium.utils import seeding

@@ -12,7 +11,7 @@ from gymnasium.utils import seeding
 T_cov = TypeVar("T_cov", covariant=True)


-MaskNDArray = npt.NDArray[np.int8]
+MaskNDArray = np.ndarray


 class Space(Generic[T_cov]):
@@ -44,7 +43,7 @@ class Space(Generic[T_cov]):
     def __init__(
         self,
         shape: Sequence[int] | None = None,
-        dtype: npt.DTypeLike | None = None,
+        dtype: np.dtype | None = None,
         seed: int | np.random.Generator | None = None,
     ):
         """Constructor of :class:`Space`.
diff --git gymnasium/spaces/text.py gymnasium/spaces/text.py
index be15be13..30bf521e 100644
--- gymnasium/spaces/text.py
+++ gymnasium/spaces/text.py
@@ -4,7 +4,6 @@ from __future__ import annotations
 from typing import Any

 import numpy as np
-from numpy.typing import NDArray

 from gymnasium.spaces.space import Space

@@ -76,7 +75,7 @@ class Text(Space[str]):

     def sample(
         self,
-        mask: None | (tuple[int | None, NDArray[np.int8] | None]) = None,
+        mask: None | (tuple[int | None, np.ndarray | None]) = None,
     ) -> str:
         """Generates a single random sample from this space with by default a random length between `min_length` and `max_length` and sampled from the `charset`.

diff --git gymnasium/spaces/utils.py gymnasium/spaces/utils.py
index e15ea467..553f60f7 100644
--- gymnasium/spaces/utils.py
+++ gymnasium/spaces/utils.py
@@ -12,7 +12,6 @@ from functools import reduce, singledispatch
 from typing import Any, TypeVar, Union, cast

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium.spaces import (
@@ -106,7 +105,7 @@ def _flatdim_text(space: Text) -> int:

 T = TypeVar("T")
 FlatType = Union[
-    NDArray[Any], typing.Dict[str, Any], typing.Tuple[Any, ...], GraphInstance
+    np.ndarray, typing.Dict[str, Any], typing.Tuple[Any, ...], GraphInstance
 ]


@@ -157,12 +156,12 @@ def flatten(space: Space[T], x: T) -> FlatType:

 @flatten.register(Box)
 @flatten.register(MultiBinary)
-def _flatten_box_multibinary(space: Box | MultiBinary, x: NDArray[Any]) -> NDArray[Any]:
+def _flatten_box_multibinary(space: Box | MultiBinary, x: np.ndarray) -> np.ndarray:
     return np.asarray(x, dtype=space.dtype).flatten()


 @flatten.register(Discrete)
-def _flatten_discrete(space: Discrete, x: np.int64) -> NDArray[np.int64]:
+def _flatten_discrete(space: Discrete, x: np.int64) -> np.ndarray:
     onehot = np.zeros(space.n, dtype=space.dtype)
     onehot[x - space.start] = 1
     return onehot
@@ -170,8 +169,8 @@ def _flatten_discrete(space: Discrete, x: np.int64) -> NDArray[np.int64]:

 @flatten.register(MultiDiscrete)
 def _flatten_multidiscrete(
-    space: MultiDiscrete, x: NDArray[np.int64]
-) -> NDArray[np.int64]:
+    space: MultiDiscrete, x: np.ndarray
+) -> np.ndarray:
     offsets = np.zeros((space.nvec.size + 1,), dtype=np.int32)
     offsets[1:] = np.cumsum(space.nvec.flatten())

@@ -181,7 +180,7 @@ def _flatten_multidiscrete(


 @flatten.register(Tuple)
-def _flatten_tuple(space: Tuple, x: tuple[Any, ...]) -> tuple[Any, ...] | NDArray[Any]:
+def _flatten_tuple(space: Tuple, x: tuple[Any, ...]) -> tuple[Any, ...] | np.ndarray:
     if space.is_np_flattenable:
         return np.concatenate(
             [np.array(flatten(s, x_part)) for x_part, s in zip(x, space.spaces)]
@@ -190,7 +189,7 @@ def _flatten_tuple(space: Tuple, x: tuple[Any, ...]) -> tuple[Any, ...] | NDArra


 @flatten.register(Dict)
-def _flatten_dict(space: Dict, x: dict[str, Any]) -> dict[str, Any] | NDArray[Any]:
+def _flatten_dict(space: Dict, x: dict[str, Any]) -> dict[str, Any] | np.ndarray:
     if space.is_np_flattenable:
         return np.concatenate(
             [np.array(flatten(s, x[key])) for key, s in space.spaces.items()]
@@ -204,8 +203,8 @@ def _flatten_graph(space: Graph, x: GraphInstance) -> GraphInstance:

     def _graph_unflatten(
         unflatten_space: Discrete | Box | None,
-        unflatten_x: NDArray[Any] | None,
-    ) -> NDArray[Any] | None:
+        unflatten_x: np.ndarray | None,
+    ) -> np.ndarray | None:
         ret = None
         if unflatten_space is not None and unflatten_x is not None:
             if isinstance(unflatten_space, Box):
@@ -229,7 +228,7 @@ def _flatten_graph(space: Graph, x: GraphInstance) -> GraphInstance:


 @flatten.register(Text)
-def _flatten_text(space: Text, x: str) -> NDArray[np.int32]:
+def _flatten_text(space: Text, x: str) -> np.ndarray:
     arr = np.full(
         shape=(space.max_length,), fill_value=len(space.character_set), dtype=np.int32
     )
@@ -279,13 +278,13 @@ def unflatten(space: Space[T], x: FlatType) -> T:
 @unflatten.register(Box)
 @unflatten.register(MultiBinary)
 def _unflatten_box_multibinary(
-    space: Box | MultiBinary, x: NDArray[Any]
-) -> NDArray[Any]:
+    space: Box | MultiBinary, x: np.ndarray
+) -> np.ndarray:
     return np.asarray(x, dtype=space.dtype).reshape(space.shape)


 @unflatten.register(Discrete)
-def _unflatten_discrete(space: Discrete, x: NDArray[np.int64]) -> np.int64:
+def _unflatten_discrete(space: Discrete, x: np.ndarray) -> np.int64:
     nonzero = np.nonzero(x)
     if len(nonzero[0]) == 0:
         raise ValueError(
@@ -297,8 +296,8 @@ def _unflatten_discrete(space: Discrete, x: NDArray[np.int64]) -> np.int64:

 @unflatten.register(MultiDiscrete)
 def _unflatten_multidiscrete(
-    space: MultiDiscrete, x: NDArray[np.integer[Any]]
-) -> NDArray[np.integer[Any]]:
+    space: MultiDiscrete, x: np.ndarray
+) -> np.ndarray:
     offsets = np.zeros((space.nvec.size + 1,), dtype=space.dtype)
     offsets[1:] = np.cumsum(space.nvec.flatten())
     nonzero = np.nonzero(x)
@@ -316,7 +315,7 @@ def _unflatten_multidiscrete(

 @unflatten.register(Tuple)
 def _unflatten_tuple(
-    space: Tuple, x: NDArray[Any] | tuple[Any, ...]
+    space: Tuple, x: np.ndarray | tuple[Any, ...]
 ) -> tuple[Any, ...]:
     if space.is_np_flattenable:
         assert isinstance(
@@ -335,7 +334,7 @@ def _unflatten_tuple(


 @unflatten.register(Dict)
-def _unflatten_dict(space: Dict, x: NDArray[Any] | dict[str, Any]) -> dict[str, Any]:
+def _unflatten_dict(space: Dict, x: np.ndarray | dict[str, Any]) -> dict[str, Any]:
     if space.is_np_flattenable:
         dims = np.asarray([flatdim(s) for s in space.spaces.values()], dtype=np.int_)
         list_flattened = np.split(x, np.cumsum(dims[:-1]))
@@ -375,7 +374,7 @@ def _unflatten_graph(space: Graph, x: GraphInstance) -> GraphInstance:


 @unflatten.register(Text)
-def _unflatten_text(space: Text, x: NDArray[np.int32]) -> str:
+def _unflatten_text(space: Text, x: np.ndarray) -> str:
     return "".join(
         [space.character_list[val] for val in x if val < len(space.character_set)]
     )
diff --git gymnasium/vector/async_vector_env.py gymnasium/vector/async_vector_env.py
index e6a874ae..51022752 100644
--- gymnasium/vector/async_vector_env.py
+++ gymnasium/vector/async_vector_env.py
@@ -7,7 +7,6 @@ from enum import Enum
 from typing import Any, Callable, List, Optional, Sequence, Tuple, Union

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium import logger
@@ -289,7 +288,7 @@ class AsyncVectorEnv(VectorEnv):

     def step_wait(
         self, timeout: Optional[Union[int, float]] = None
-    ) -> Tuple[Any, NDArray[Any], NDArray[Any], NDArray[Any], dict]:
+    ) -> Tuple[Any, np.ndarray, np.ndarray, np.ndarray, dict]:
         """Wait for the calls to :obj:`step` in each sub-environment to finish.

         Args:
diff --git gymnasium/vector/sync_vector_env.py gymnasium/vector/sync_vector_env.py
index fdcc6f59..9148ef71 100644
--- gymnasium/vector/sync_vector_env.py
+++ gymnasium/vector/sync_vector_env.py
@@ -3,7 +3,6 @@ from copy import deepcopy
 from typing import Any, Callable, Iterable, List, Optional, Sequence, Tuple, Union

 import numpy as np
-from numpy.typing import NDArray

 from gymnasium import Env
 from gymnasium.spaces import Space
@@ -132,7 +131,7 @@ class SyncVectorEnv(VectorEnv):
         """Sets :attr:`_actions` for use by the :meth:`step_wait` by converting the ``actions`` to an iterable version."""
         self._actions = iterate(self.action_space, actions)

-    def step_wait(self) -> Tuple[Any, NDArray[Any], NDArray[Any], NDArray[Any], dict]:
+    def step_wait(self) -> Tuple[Any, np.ndarray, np.ndarray, np.ndarray, dict]:
         """Steps through each of the environments returning the batched results.

         Returns:
diff --git gymnasium/vector/vector_env.py gymnasium/vector/vector_env.py
index 70b98858..1e48f4d8 100644
--- gymnasium/vector/vector_env.py
+++ gymnasium/vector/vector_env.py
@@ -2,7 +2,6 @@
 from typing import Any, List, Optional, Tuple, Union

 import numpy as np
-from numpy.typing import NDArray

 import gymnasium as gym
 from gymnasium.vector.utils.spaces import batch_space
@@ -149,7 +148,7 @@ class VectorEnv(gym.Env):

     def step_wait(
         self, **kwargs
-    ) -> Tuple[Any, NDArray[Any], NDArray[Any], NDArray[Any], dict]:
+    ) -> Tuple[Any, np.ndarray, np.ndarray, np.ndarray, dict]:
         """Retrieves the results of a :meth:`step_async` call.

         A call to this method must always be preceded by a call to :meth:`step_async`.
@@ -164,7 +163,7 @@ class VectorEnv(gym.Env):

     def step(
         self, actions
-    ) -> Tuple[Any, NDArray[Any], NDArray[Any], NDArray[Any], dict]:
+    ) -> Tuple[Any, np.ndarray, np.ndarray, np.ndarray, dict]:
         """Take an action for each parallel environment.

         Args:
diff --git gymnasium/envs/registration.py gymnasium/envs/registration.py
index 8d6d1e8c..40e6e796 100644
--- gymnasium/envs/registration.py
+++ gymnasium/envs/registration.py
@@ -554,7 +554,12 @@ def load_plugin_envs(entry_point: str = "gymnasium.envs"):
         entry_point: The string for the entry point.
     """
     # Load third-party environments
-    for plugin in metadata.entry_points(group=entry_point):
+    print("entry: ", entry_point)
+    print(metadata.entry_points(group=entry_point))
+    print(metadata.entry_points().keys())
+    print("type: ", type(metadata.entry_points()))
+    print("dir: ", metadata.entry_points().__dir__())
+    for plugin in metadata.entry_points().select(group=entry_point):
         # Python 3.8 doesn't support plugin.module, plugin.attr
         # So we'll have to try and parse this ourselves
         module, attr = None, None